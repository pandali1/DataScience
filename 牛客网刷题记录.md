@[TOC](牛客网刷题记录)

## 1.

```mysql
select * from employees
    order by hire_date desc
    limit 0,1;
    
    
select 
* 
from employees
where hire_date = 
    (
         select 
         max(hire_date) 
         from employees
    )
```

- limit m,n 从m+1处开始，返回n行，m可以省略
- 使用子查询的方法比较准确

## 2

```mysql
select
*
from employees
where hire_date = 
    (
        select 
         distinct hire_date 
         from employees
        order by hire_date desc
        limit 2,1
    )
```

- 注意使用distinct进行去重

## 3

1. ```mysql
   select
   b.*,a.dept_no
   from dept_manager a left join salaries b
   on a.emp_no = b.emp_no
   where a.to_date='9999-01-01'
   and b.to_date='9999-01-01'
   ORDER BY b.emp_no
   ```

   - 注意过滤掉已经离职的领导

## 4

 ```mysql
   select last_name
   ,first_name
   ,dept_no
   from employees inner join dept_emp
   on employees.emp_no = dept_emp.emp_no
 ```

   - 注意使用内连接
   - **注意连接时，大表（数据量多的表要放在前面）**

## 5

 ```mysql
   -- 筛选变动次数超过15次的员工
   select 
   emp_no
   ,count()
   from salaries
   group by emp_no
   having count()>15
   
   -- 筛选加薪次数超过15次的员工
   select 
   a.emp_no
   , count(*) as t
   from salaries a 
   inner join salaries b
   on a.emp_no=b.emp_no
   where a.salaries < b.salaries
   group by a.emp_no
   having t>15
 ```

   - 在第二个语句中，使用了自连接来，筛选出加薪的员工
   - 当遇到一个同个字段进行比较时，**应该使用自连接**

## 7

 ```mysql
   --使用distinct进行去重
   select 
   distinct salary
   from salaries
   where to_date = '9999-01-01'
   order by salary desc
   
   -- 使用groupby进行去重
   select 
   salary
   from salaries
   where to_date = '9999-01-01'
   group by salary
   order by salary desc
 ```

   - 当数据量较大时，建议使用groupby进行去重
   - **distinct会将select之后的所有字段合并进行去重**

## 8

 ```mysql
   -- 使用join+is null
   select
   employees.emp_no
   from employees 
   left join dept_manager
   on employees.emp_no = dept_manager.emp_no
   where dept_manager.dept_no is  null
   
   -- 使用子查询
   SELECT emp_no FROM employees
   WHERE emp_no NOT IN (SELECT emp_no FROM dept_manager)
 ```

   - 判断非空时，应该使用` is null / is not null`,不能使用`!=null`
   - 连接的性能要高于子查询，尽量使用连接而不是子查询

## 10

 ```mysql
     select 
     a.emp_no
     ,b.emp_no
     from dept_emp a inner join dept_manager b
     on a.dept_no = b.dept_no
     where a.emp_no != b.emp_no
     and a.to_date = '9999-01-01' 
     AND b.to_date = '9999-01-01'
 ```

## 11

 ```mysql
     -- 使用子查询方法
     select
     d1.dept_no
     ,d1.emp_no
     ,s1.salary
     from salaries s1 inner join dept_emp d1
     on s1.emp_no = d1.emp_no
     AND d1.to_date='9999-01-01'
     AND s1.to_date='9999-01-01'
     where s1.salary in 
      (
          select max(s2.salary)
          from salaries s2 inner join dept_emp d2
          on s2.emp_no = d2.emp_no
          AND d2.to_date='9999-01-01'
          AND s2.to_date='9999-01-01'
          AND d2.dept_no = d1.dept_no -- 利用内查询获取外查询的部门编号
      )
     order by d1.dept_no asc
     
 ```

##     ==12==

   ```

   -- 使用开窗函数
   select
   t.dept_no
   ,t.emp_no
   ,t.salary
   from
       (
           select
           d.dept_no
           ,d.emp_no
           ,s.salary
           ,dense_rank() over (partition by d.dept_no order by s.salary desc) as rk
           from dept_emp d inner join salaries s
           on d.emp_no = s.emp_no
           where d.to_date='9999-01-01'
           and s.to_date='9999-01-01'
       ) t
   where t.rk = 1
   ```

   - ==开窗函数使用方法==[链接](https://blog.csdn.net/weixin_43412569/article/details/107992998)
   - dense_rank() 对每个dept_no部门中的partition分组数据进行排序
   - row_number()，rank()，ntile(n),以及其他聚合函数

## 15

15. ```mysql
    select
    *
from employees
    where emp_no%2=1
    and last_name != 'Mary'
    order by hire_date desc
    ```
- ==不等于的几种表示方法==
  - !=
  - is not
  - <>
- ==基数的表示方法==
  - x%2=1
  - x&1 使用了位运算

## 16

```mysql
select 
title
,avg(salary)as avg_salary
from salaries s inner join titles t
on s.emp_no = t.emp_no
where s.to_date='9999-01-01'
group by title
order by avg_salary
```

## 17

```mysql
select 
emp_no
,salary
from salaries
order by salary desc
limit 1,1
```

## ==18==

```mysql
-- 使用子查询
select 
s.emp_no
,s.salary
,e.last_name
,e.first_name
from employees e 
inner join salaries s
on e.emp_no = s.emp_no
where s.salary = 
    (
        select 
        max(salary)  -- 2 第二高工资
        from salaries
        where salary<>
        (
            select max(salary) -- 1查出最高工资
            from salaries
            where to_date='9999-01-01'
        )
    )
and s.to_date = '9999-01-01'

-- 使用自连接
select s.emp_no
, s.salary
, e.last_name
, e.first_name
from salaries s 
join employees e
on s.emp_no = e.emp_no
where s.salary =
    (
        select s1.salary
        from salaries s1 join salaries s2      -- 自连接查询
        on s1.salary <= s2.salary
        group by s1.salary                     -- 当s1<=s2链接并以s1.salary分组时一个s1会对应多个s2
        having count(distinct s2.salary) = 2   -- (去重之后的数量就是对应的名次)
    )
and s.to_date = '9999-01-01'
```

- 当不使用order by 时，可以使用**自连接或者多个子查询**

## 19 

```mysql
select last_name
,first_name
,dept_name
from employees e 
left join dept_emp d
on e.emp_no = d.emp_no
left join departments 
on d.dept_no = departments.dept_no
```

- 多表连接时的执行顺序： [链接](https://blog.csdn.net/qq_27529917/article/details/87904179)[链接](https://cloud.tencent.com/developer/article/1554927)